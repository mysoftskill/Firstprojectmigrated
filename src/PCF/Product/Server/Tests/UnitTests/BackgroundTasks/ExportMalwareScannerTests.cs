namespace PCF.UnitTests.BackgroundTasks
{
    using System;
    using System.IO;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.PrivacyServices.CommandFeed.Service.BackgroundTasks.CommandStatusAggregation;
    using Microsoft.PrivacyServices.CommandFeed.Service.Common;
    using Moq;
    using Xunit;

    [Trait("Category", "UnitTest")]
    public class ExportMalwareScannerTests
    {
        // These unit tests require setting static values which might be modified
        // when tests run in parallel.  Attempt to sychronize test execution with this semaphore.
        static SemaphoreSlim semaphoreSlim = new SemaphoreSlim(1, 1);

        /// <summary>
        /// Validates malware scan is skipped if flighting is disabled.
        /// </summary>
        /// <returns></returns>
        [Fact]
        public async Task SkipScanIfFlightDisabled()
        {
            var featureValue = Config.Instance.Worker.DefenderPipelineEnabled;

            await semaphoreSlim.WaitAsync();
            try
            {
                Config.Instance.Worker.DefenderPipelineEnabled = true;

                using (var stream = new MemoryStream(Encoding.UTF8.GetBytes("abcd")))
                using (var scanner = new ExportMalwareScanner(new Mock<IDefender>().Object))
                {
                    var result = await scanner.ScanAsync(
                        "test_path.txt",
                        stream,
                        new CommandId(Guid.NewGuid()),
                        DateTime.UtcNow,
                        CancellationToken.None);

                    Assert.False(result.IsMalware);
                }
            }
            finally
            {
                Config.Instance.Worker.DefenderPipelineEnabled = featureValue;
                semaphoreSlim.Release();
            }
        }

        /// <summary>
        /// Validates malware scan is skipped if feature is disabled.
        /// </summary>
        [Fact]
        public async Task SkipScanIfFeatureDisabled()
        {
            var featureValue = Config.Instance.Worker.DefenderPipelineEnabled;

            await semaphoreSlim.WaitAsync();
            try
            {
                Config.Instance.Worker.DefenderPipelineEnabled = false;
                using (new FlightEnabled(FlightingNames.AvScanEnabled))
                using (var stream = new MemoryStream(Encoding.UTF8.GetBytes("abcd")))
                using (var scanner = new ExportMalwareScanner(new Mock<IDefender>().Object))
                {
                    var result = await scanner.ScanAsync(
                        "test_path.txt",
                        stream,
                        new CommandId(Guid.NewGuid()),
                        DateTime.UtcNow,
                        CancellationToken.None);

                    Assert.False(result.IsMalware);
                }
            }
            finally
            {
                Config.Instance.Worker.DefenderPipelineEnabled = featureValue;
                semaphoreSlim.Release();
            }
        }

        // [InlineData(<Give up scan after x hours>, <Last Agent Completed before x hour>, <Should skip scan>)]
        [Theory]
        [InlineData(3, 3, false)] // left with 3-3=0 hours to finish scan; skip scan
        [InlineData(3, 1, true)]  // left with 3-1=2 hours to finish scan; proceed with scan
        [InlineData(3, 4, false)]  // left with 3-4=-1 hours to finish scan; skip scan
        public async Task SkipScanIfThresholdExceeded(
            int thresholdHours,
            int lastAgentCompletedBefore,
            bool expectMalware)
        {
            // For this Unit test, All Scan results are assumed to return malware
            // This Test checks if scan is skipped if threshold is met and if text is replaced based on the params provided
            var defenderMock = new Mock<IDefender>();
            defenderMock.Setup(x => x.GetScanResultAsync(It.IsAny<string>(), CancellationToken.None))
                .Returns(Task.FromResult(new DefenderScanResult { IsMalware = true }));

            await RunTestAsync(defenderMock.Object, thresholdHours, lastAgentCompletedBefore, expectMalware);
        }

        [Fact]
        public async Task ShouldThrowWhenAgentCompletionTimeIsNull()
        {
            var defenderMock = new Mock<IDefender>();

            await Assert.ThrowsAsync<InvalidOperationException>(() =>
                RunTestAsync(
                    defenderMock.Object,
                    thresholdHours: 1,
                    lastAgentCompletedBefore: null,
                    expectMalware: false));
        }

        private async Task RunTestAsync(
            IDefender defender,
            int thresholdHours,
            int? lastAgentCompletedBefore,
            bool expectMalware)
        {
            var featureValue = Config.Instance.Worker.DefenderPipelineEnabled;

            await semaphoreSlim.WaitAsync();
            try
            {
                Config.Instance.Worker.DefenderPipelineEnabled = true;
                Config.Instance.Worker.DefenderThresholdHoursToSkipScan = thresholdHours;
                var completedTime = lastAgentCompletedBefore.HasValue ?
                    DateTime.UtcNow.AddHours(-Math.Abs(lastAgentCompletedBefore.Value))
                    : new Nullable<DateTime>();

                using (new FlightEnabled(FlightingNames.AvScanEnabled))
                using (var stream = new MemoryStream(Encoding.UTF8.GetBytes("abcd")))
                using (var scanner = new ExportMalwareScanner(defender))
                {
                    var result = await scanner.ScanAsync(
                        "test_path.txt",
                        stream,
                        new CommandId(Guid.NewGuid()),
                        completedTime,
                        CancellationToken.None);

                    Assert.True(expectMalware == result.IsMalware);
                }
            }
            finally
            {
                Config.Instance.Worker.DefenderPipelineEnabled = featureValue;
                semaphoreSlim.Release();
            }
        }
    }
}
