namespace Microsoft.PrivacyServices.CommandFeed.Service.BackgroundTasks.CommandStatusAggregation
{
    using System;
    using System.IO;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Azure.ComplianceServices.Common.Instrumentation;
    using Microsoft.PrivacyServices.CommandFeed.Service.Common;
    using Microsoft.PrivacyServices.Common.Azure;

    /// <summary>
    /// Scans a source stream for malware.
    /// </summary>
    public class ExportMalwareScanner : IExportMalwareScanner
    {
        private IDefender defender;
        private bool disposedValue;

        /// <summary>
        /// Gets the underlying stream that was scanned.
        /// </summary>
        public Stream ScanStream { get; private set; }

        /// <summary>
        /// Constructs a new instance of <see cref="ExportMalwareScanner"/>.
        /// </summary>
        /// <param name="defender">Defender to detect malware.</param>
        public ExportMalwareScanner(IDefender defender)
        {
            this.defender = defender;
        }

        /// <summary>
        /// Scans the source stream for malware.
        /// Creates a scan stream backed by a temporary file on local disk.
        /// </summary>
        /// <param name="destinationPath">Path for the stream.</param>
        /// <param name="stream">Source stream.</param>
        /// <param name="commandId">Id for the export command.</param>
        /// <param name="maxCompletedTime">Maximum completed time for export commands.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>Scan result.</returns>
        public async Task<DefenderScanResult> ScanAsync(
            string destinationPath,
            Stream stream,
            CommandId commandId,
            DateTimeOffset? maxCompletedTime,
            CancellationToken cancellationToken)
        {
            DefenderScanResult result = new DefenderScanResult();

            DualLogger.Instance.Information(
                nameof(ExportMalwareScanner),
                $"Determining if defender pipeline is enabled for {commandId}");

            // Copy the file from the source onto the file system. We'll need to seek within the stream
            // and a memory stream may not be large enough.
            string tempFileName = Path.Combine(Config.Instance.Worker.DefenderFileDownloadTempDirectory, Guid.NewGuid().ToString("n") + ".avscan");

            Directory.CreateDirectory(Config.Instance.Worker.DefenderFileDownloadTempDirectory);

            // 4096 is the default buffer size used with File.Create(fileName), there's not a default when passing file options.
            if (this.ScanStream != null)
            {
                this.ScanStream.Dispose();
            }

            this.ScanStream = File.Create(tempFileName, 4096, FileOptions.DeleteOnClose);
            // Make a copy of source stream for defender scanning
            // Source stream position can not be set to begin as its a deflated stream, hence a copy of it is required
            await stream.CopyToAsync(this.ScanStream, 4096, cancellationToken);
            this.ScanStream.Position = 0;

            if (Config.Instance.Worker.DefenderPipelineEnabled &&
            FlightingUtilities.IsEnabled(FlightingNames.AvScanEnabled))
            {
                DateTimeOffset thresholdTimeToSkipScan =
                    maxCompletedTime.Value.AddHours(Config.Instance.Worker.DefenderThresholdHoursToSkipScan);

                try
                {
                    DualLogger.Instance.Information(
                        nameof(ExportMalwareScanner),
                        $"Determining if threshold to skip scan is met for {commandId} " +
                        $"with thresholdTimeToSkipScan: [{thresholdTimeToSkipScan}], CurrentDateTime: [{DateTimeOffset.UtcNow}]");

                    if (DateTimeOffset.UtcNow < thresholdTimeToSkipScan)
                    {
                        await Logger.InstrumentAsync(
                            new OperationEvent(SourceLocation.Here()),
                            async ev =>
                            {
                                ev["Step"] = $"ScanForMalwareAsync";
                                ev["CommandId"] = $"{commandId}";
                                ev["ThresholdTimeToSkipScan"] = $"{thresholdTimeToSkipScan}";
                                ev["File"] = $"{destinationPath}";

                                result = await this.defender.ScanForMalwareAsync(this.ScanStream, cancellationToken);

                                ev["IsMalware"] = $"{result.IsMalware}";
                                ev["DeterminationType"] = $"{result.DeterminationType}";
                                ev["Determination"] = $"{result.ScanDetermination}";

                                DualLogger.Instance.Information(
                                    nameof(ExportMalwareScanner),
                                    $"Scan result found for file [{destinationPath}], IsMalware:{result.IsMalware}");
                            });
                    }
                }
                catch (Exception ex)
                {
                    DualLogger.Instance.Error(
                        nameof(ExportMalwareScanner),
                        ex,
                        $"Exception occurred while scanning file [{destinationPath}], " +
                        $"Command Id: {commandId}, LastAgentCompletedTime: [{maxCompletedTime}], " +
                        $"ThresholdTimeToSkipScan: [{thresholdTimeToSkipScan}]");
                    throw;
                }
            }

            return result;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if (this.ScanStream != null)
                    {
                        this.ScanStream.Dispose();
                    }
                }

                disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
